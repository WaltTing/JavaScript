# 正则表达式入门
正则表达式应用范围非常广，见诸于平时的字符验证、登录验证的场合中，对于初学者来说，处理一大串类似于乱码的字符是一件很头疼的事。

前几天在慕课网上找了一个视频，是一个很不错的教程：
[javaScript正则表达式](http://www.imooc.com/learn/706)

## 正则表达式检测工具

[regexper.com](https://regexper.com/)

## 元字符
正则表达式由两种字符类型组成：
- 原义文本字符
- 元字符

元字符是正则表达式中有特殊含义的非字母字符。

字符 | 含义
-- | --
\t | 水平制表符
\v | 垂直制表符
\n | 换行符
\r | 回车符
\0 | 空字符
\f | 换页符
\cX | 与X对应的控制字符（Ctrl+X）
## 字符类 

- 我们可以使用元字符[]来构建一个简单的类   
- 所谓的类是指符合某些特性的对象，一个泛指，而不是特指某个字符        
- 表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类的字符

## 字符串取反

- 使用元字符^创建反向类/负向类
- 反向类的意思是不属于某类的内容
- 表达式[^abc]表示不是字符a或b或c的内容

## 范围类

- 正则表达式还提供了范围类
- 所以我们可以使用[a-z]来连接两个字符表示从a到z的任意字符
- 这是个闭区间，包含a和z本身
- 在[]组成的类内部是可以连写的[a-zA-Z0-9]

分析符合下面要求的正则表达式：

> 将2016-09-12 全部替换成A(包括-)

则可以这样来匹配：

    '2016-09-12'.replace(/[0-9-]/g,'A');
    
## 预定义类

字符|等价类|含义 
---|---|---
.|[^\r\n] | 除了回车符和换行符之外的所有字符
\d|[0-9]|数字字符
\D|[^0-9]|非数字字符
\s|[\t\n\x0B\f\r]|空白符
\S|[^\t\n\x0B\f\r]|非空白字符
\w|[a-zA-Z_0-9]|单词字符（字母、数字下划线）
\W|[^a-zA-Z_0-9]|非单词字符

## 边界
正则表达式还提供了几个常用的边界匹配字符

字符|含义  
--|--  
^|以xxx开始
$|以XXX结束
\b|单词边界
\B|非单词边界

注意：元字符在不同情景下可能会有不同的含义，^在中括号外就表示 "以XXX开始"，中括号内表示取反。

## 量词
我们希望匹配一个连续出现20次数字的字符串  

字符|含义
--|--
？|出现零次或一次（最多出现一次）
+|出现一次或多次（至少出现一次）
*|出现零次或多次（任意次）
{n}|出现n次
{n,m}|出现n到m次
{n,}|至少出现n次

如：

    \d{20}\w\d?\w+\d*\d{3}\w{3,5}\d{3,}
    
## 贪婪模式
\d{3,6}，比如

    '12345678'.replace('\d{3,6}','X');  //X78
    
正则表达式会尽可能多地匹配，直到匹配失败为止。

## 非贪婪模式
- 让正则表达式尽可能少的匹配，也就是说一旦匹配成功就不再继续尝试，就是非贪婪模式
- 做法很简单，在量词后面加上问号？即可

        '12345678'.replace('\d{3,6}?','X');  //XX78
    
## 分组
> 匹配字符串Byron连续出现三次的情景   
> Byron{3}是匹配n出现三次的情况。
  
使用（）可以达到分组的功能，使量词作用于分组。

    Byron{3}
    
例子：匹配出现字母数字连续出现3次的情况:

'a1b2c3d4'.replace(/([a-z]\d){3}/,'X');  //'Xd4'

## 或
使用|可以达到效果  
## 反向引用

> 2016-12-25 => 12/25/2016

    '2016-12-25'.replace('/(\d{4})-(\d{2})-(\d{2})/g','$1$2$3'); // 2016/12/25
    '2016-12-25'.replace('/(\d{4})-(\d{2})-(\d{2})/g','$2$3$1'); // 12/25/2016

也叫分组捕获，$可以捕获到前面的分组。

## 忽略分组
不希望捕获某些分组，只要在分组内加上?:即可。  
比如：

(?:Byron).(ok) //ok被忽略

## 前瞻

- 正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前”
- 前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾方向则相反
- 符合和不符合特定断言称为肯定/正向 匹配和否定/负向 匹配。

名称|正则|含义
--|--|--
正向前瞻|exp(?=assert)|
负向前瞻|exp(?!assert)|
比如： 
  
    \w(?=\d)  //能够匹配字符的情况下，后面的字符还得是数字类型
    
比如：

    'a2*3'.replace(/\w(?=\d)/g,'X'); //"X2*3"

## 后顾
JS不支持后顾。
## 对象属性
- global:是否全文搜索默认false
- ignore case:是否大小写敏感，默认是false
- multiline:多行搜索，默认值是false
- lastIndex:是当前表达式匹配内容的最后一个字符的下一个位置
- source:正则表达式的文本字符串










